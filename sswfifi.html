<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <title>KLAP_receiver_WiFi</title>
    <link rel="manifest" href="/manifest.json">
    <style>
        html, body {
            height: 100%;
            margin: 0;
        }

        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; 
            min-height: 100vh;
            background-color: #000000;
            color: #ffffff;
            padding: 10px;
            position: relative;
        }

        #container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #000000;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            padding-top: 20px; 
            padding-bottom: 5px; 
            padding-left: 20px;
            padding-right: 20px;
            max-width: 100%;
            margin: 0 auto; 
            width: 100%;
            box-sizing: border-box;
            height: calc(100vh - 20px); 
            position: relative;
        }
        
        /* 2„Ç´„É©„É†ÊßãÈÄ† */
        #main-content {
            display: flex;
            flex-direction: row; 
            width: 100%;
            gap: 15px;
            align-items: flex-start; 
            flex-grow: 1; 
            min-height: 0; 
            margin-bottom: 50px; 
            
            position: relative;
            z-index: 10; 
        }
        
        /* Â∑¶„Ç´„É©„É†Ôºà„É™„Ç¢„É´„É©„ÉÉ„Éó„ÄÅÁµåÈÅéÊôÇÈñì„ÄÅ„É°„ÉÉ„Çª„Éº„Ç∏Ôºâ - ÂπÖ65% */
        #left-column {
            display: flex;
            flex-direction: column;
            flex-basis: 65%; 
            max-width: 65%;
            flex-shrink: 0; 
            align-items: center;
            gap: 0px; 
        }

        /* Âè≥„Ç´„É©„É†Ôºà„É©„ÉÉ„ÉóÂ±•Ê≠¥Ôºâ - ÂπÖ35% */
        #right-column {
            display: flex;
            flex-direction: column;
            flex-basis: 35%; 
            max-width: 35%;
            flex-grow: 1; 
            align-items: center;
            height: 100%; 
        }

        #time-display-column {
            width: 100%; 
        }
        
        /* Ë®àÊ∏¨„É©„ÉÉ„Éó (display1) */
        #display1 {
            font-size: 100px; 
            font-weight: bold;
            color: #eeeeee;
            margin-bottom: 0px; 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: clip; 
        }

        /* ÁµåÈÅéÊôÇÈñì (display) */
        #display {
            font-size: 70px; 
            font-weight: bold;
            color: #cccccc;
            margin-bottom: 0px; 
            white-space: nowrap;
            overflow: hidden; 
            text-overflow: clip;
        }

        /* „Éî„ÉÉ„Éà„É°„ÉÉ„Çª„Éº„Ç∏ */
        #pitMessageDisplay {
            width: 100%;
            margin: 0; 
            font-size: 1.8em; 
            padding: 10px; 
            font-weight: bold; 
            color: #ffeb3b; 
            background: #000000; 
            border: none; 
            border-radius: 5px; 
            min-height: 25px;
            text-align: left; 
            display: none; 
        }

        /* „É©„ÉÉ„Éó„É™„Çπ„Éà„ÅÆË™øÊï¥ */
        #lap_list {
            width: 100%;
            height: 100%; 
            max-height: none; 
            overflow-y: auto;
            border: none;
            border-radius: 5px;
            background-color: #000000;
            padding: 10px;
        }

        /* „É©„ÉÉ„ÉóÂ±•Ê≠¥„ÅÆÊñáÂ≠ó„Çí2.0em„Å´Êã°Â§ß */
        #lap_list div {
            font-size: 2.0em; 
            margin-bottom: 3px;
            color: #dddddd;
            text-align: right; 
            white-space: nowrap; 
        }

        #buttons-row {
            display: flex;
            justify-content: space-around;
            width: 100%;
            gap: 15px;
            padding-top: 10px;
            margin-bottom: 0; 
            flex-shrink: 0; 
        }
        
        .button {
            border: 1px solid #3a3a3c;
            background-color: #2c2c2e;
            padding: 10px 15px;
            color: #ffffff;
            font-size: 16px;
            font-weight: 500;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            text-align: center;
            flex-grow: 1; 
            flex-basis: 0;
            background-color: #2c2c2e; 
        }
        
        .button:hover { background-color: #4a4a4e; }
        #start:active { background-color: #4a804a; }
        #lap:active { background-color: #4a4a4e; }
        
        .no-setting { background-color: #ff4d4d !important; }
        .active-blue { background-color: #007aff !important; }
        .no-gps { background-color: #ff4d4d !important; }

        /* Wi-FiÊé•Á∂ö„ÅÆÁä∂ÊÖã„ÇíÁ§∫„Åô„ÇØ„É©„Çπ */
        .wifi-disconnected { background-color: #ff4d4d !important; border-color: #993333;}
        .wifi-connected { background-color: #007aff !important; border-color: #0066cc;}
        .wifi-connecting { background-color: #ffcc00 !important; border-color: #cc9900;}
        .wifi-error { background-color: #ff0000 !important; border-color: #cc0000;} 

        /* debug-overlay */
        #debug-overlay {
            position: absolute; 
            top: 0;
            left: 0;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.7); 
            color: #999999;
            padding: 5px 10px;
            border-radius: 10px 10px 0 0; 
            font-size: 14px;
            line-height: 1.5;
            box-sizing: border-box;
            z-index: 5;
            display: none;}
        .status-text { text-align: left; margin: 0; }
        
        /* „É¢„Éê„Ç§„É´„Éì„É•„Éº„Åß„ÅÆ„Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫ÂÜçË™øÊï¥ */
        @media (max-width: 768px) {
            #main-content {
                flex-direction: column;
                align-items: center;
                gap: 10px;
                flex-grow: 0; 
                margin-bottom: 25px; 
            }
            #left-column, #right-column {
                flex-basis: 100%;
                max-width: 100%;
                width: 100%;
                height: auto; 
                flex-shrink: 1; 
            }
            #left-column {
                gap: 0px; 
            }
            #display1 { font-size: 80px; } 
            #display { font-size: 45px; }
            #lap_list {
                height: 30vh; 
                min-height: 180px;
                font-size: 1em;
            }
            /* „É¢„Éê„Ç§„É´ÊôÇ„ÅÆ„É©„ÉÉ„ÉóÂ±•Ê≠¥„ÅÆÊñáÂ≠ó„Çí3.0em„Å´Êã°Â§ß */
            #lap_list div {
                font-size: 3.0em;
                text-align: right;
            }
            #pitMessageDisplay {
                font-size: 1.6em; 
                padding: 8px; 
            }
            .button {
                font-size: 12px;
            }
        }
    </style>
</head>

<body>
<div id="container">
    
    <div id="debug-overlay">
        <p id="status-display" class="status-text">GPSË®≠ÂÆö: Êú™ÂèñÂæó</p>
        <p id="debugInfo" class="status-text"></p>
    </div>
    
    <div id="main-content">
        
        <div id="left-column">
             <div id="time-display-column">
                 <div id='display1'>00:00.000</div>
                 <div id='display'>00:00:00.000</div>
            </div>

            <div id="pitMessageDisplay"></div>
        </div>
        
        <div id="right-column">
            <div id='lap_list'></div>
        </div>
        
    </div>
    
    <div id="buttons-row">
        <button id="start" class="button">start</button>
        <button id="lap" class="button">LAP</button> 
        <button id="gpsButton" class="button no-gps">GPS</button>
        <button id="getSettingsBtn" class="button no-setting">GET</button>
        <button id="wifiButton" class="button wifi-disconnected">Wi-Fi</button> 
    </div>

</div>

<script>
'use strict';
// ----------------------------------------------------
// ‚òÖ‚òÖ‚òÖ WebSocketÂÆöÊï∞„Å®Â§âÊï∞ ‚òÖ‚òÖ‚òÖ
// ----------------------------------------------------
// Â§âÊõ¥ÁÇπ: „Éù„Éº„Éà„Çí81„Åã„ÇâÊ®ôÊ∫ñ„ÅÆ80„Å´Â§âÊõ¥„ÄÇ„Åª„Å®„Çì„Å©„ÅÆESP32„ÅÆWeb„Çµ„Éº„Éê„Éº/WebSocket„ÅØ80„ÅßÂãï‰Ωú„Åó„Åæ„Åô„ÄÇ
const WS_PORT = '80'; // ESP32„ÅÆWebSocket„Éù„Éº„Éà („Éá„Éï„Ç©„É´„Éà: 80)
const WS_PATH = '';   // Êé•Á∂ö„Éë„ÇπÔºàÈÄöÂ∏∏„ÅØÁ©∫„ÄÅ'/ws'„ÅåÂøÖË¶Å„Å™Â†¥Âêà„ÅØÂ§âÊõ¥Ôºâ
const API_ENDPOINT_KEY = 'pitMessageApiHost'; // „Ç≠„ÉºÂêç„ÇíIP/„Éõ„Çπ„ÉàÂêç„Å´Âêà„Çè„Åõ„Å¶Â§âÊõ¥

let socket = null;
let retryCount = 0;
let connectAttemptTimerId = null;

// --- „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞ ---
const SW_STATE = { STOP: 0, RUN: 1, PAUSE: 2 };
let swState = SW_STATE.STOP;
let startTime = 0;
let lapRecords = [];
let lapCount = 0;
let countUpTimerId = null;
let lapTimerId = null;
let lapStartTime = 0;
let gpsWatchId = null;
let isGpsRunning = false;
let lastPosition = null;
let previousSideOfLine = null;
let lastLapTime = 0;
let gpsThresholdValue = 20;
let lapCoolDown = 15000;
let isSettingsLoaded = false;
let lapFixedDisplayTimeoutId = null;

const elem = {
    display: null,
    display1: null,
    lap_list: null,
    statusDisplay: null,
    debugInfo: null,
    startButton: null,
    lapButton: null,
    gpsButton: null,
    getSettingsBtn: null,
    wifiButton: null, 
    pitMessageDisplay: null
};

// GPS„É©„ÉÉ„ÉóË®àÊ∏¨Áî®Â§âÊï∞ - localStorage„Åã„ÇâË™≠„ÅøËæº„ÇÄ
let LAP_LINE_P1 = { lat: 0, lon: 0 };
let LAP_LINE_P2 = { lat: 0, lon: 0 };

// --- „Çπ„Éà„ÉÉ„Éó„Ç¶„Ç©„ÉÉ„ÉÅÈñ¢ÈÄ£„ÅÆÈñ¢Êï∞ÔºàÂ§âÊõ¥„Å™„ÅóÔºâ ---
const totalTimePrint = (time) => {
    let h = Math.floor(time / 3600000);
    let m = Math.floor((time % 3600000) / 60000);
    let s = Math.floor((time % 60000) / 1000);
    let ms = Math.floor(time % 1000);
    
    h = ('0' + h).slice(-2);
    m = ('0' + m).slice(-2);
    s = ('0' + s).slice(-2);
    ms = ('00' + ms).slice(-3);
    
    if (elem.display) elem.display.textContent = `${h}:${m}:${s}.${ms}`;
};

const lapTimeToString = (time) => {
    let m = Math.floor(time / 60000);
    let s = Math.floor(time % 60000 / 1000);
    let ms = Math.floor(time % 1000);
    
    m = ('0' + m).slice(-2);
    s = ('0' + s).slice(-2);
    ms = ('00' + ms).slice(-3);
    
    return `${m}:${s}.${ms}`;
};

const countUp = () => {
    countUpTimerId = requestAnimationFrame(() => {
        const now = Date.now();
        const elapsedTime = now - startTime;
        totalTimePrint(elapsedTime);
        countUp();
    });
};

const startRealtimeLap = () => {
    if (swState === SW_STATE.RUN) {
        lapTimerId = requestAnimationFrame(() => {
            const now = Date.now();
            const lapElapsedTime = now - lapStartTime;
            const lapDisplay = lapTimeToString(lapElapsedTime);
            if (elem.display1) elem.display1.textContent = lapDisplay;
            startRealtimeLap();
        });
    }
};

const lapTimePrint = (time) => { 
    const lapDuration = lapTimeToString(time);
    const lapDiv = document.createElement('div');
    lapDiv.textContent = `[${lapCount}] ${lapDuration}`; 
    lapDiv.style.fontSize = '2.0em'; 
    lapDiv.style.textAlign = 'right'; 
    if (elem.lap_list) {
        elem.lap_list.insertBefore(lapDiv, elem.lap_list.firstChild);
    }
    lapRecords.push({ count: lapCount, time: lapDuration }); 
};

const updateButtonDisplay = () => {
    if (elem.lapButton) {
        if (swState === SW_STATE.RUN) {
            elem.lapButton.textContent = 'LAP';
        } else if (swState === SW_STATE.PAUSE) {
            elem.lapButton.textContent = 'RESET';
        } else { 
            elem.lapButton.textContent = 'LAP'; 
        }
    }
    if (elem.startButton) {
        elem.startButton.textContent = (swState === SW_STATE.RUN) ? 'stop' : 'start';
    }
};

const clickStartSW = () => {
    console.log("start/stop button clicked"); 
    
    if (!isSettingsLoaded && swState === SW_STATE.STOP) {
        if (elem.debugInfo) {
            elem.debugInfo.textContent = "GPSË®≠ÂÆö„ÅåÊú™ÂèñÂæó„Åß„Åô„ÄÇÊâãÂãï„Åß„ÅÆË®àÊ∏¨„ÇíÈñãÂßã„Åó„Åæ„Åô„ÄÇ";
        }
    }
    
    if (swState === SW_STATE.STOP) {
        swState = SW_STATE.RUN;
        startTime = Date.now();
        lapStartTime = Date.now();
        lapCount = 0;
        elem.lap_list.innerHTML = '';
        countUp();
        startRealtimeLap();
    } else if (swState === SW_STATE.RUN) {
        swState = SW_STATE.PAUSE;
        cancelAnimationFrame(countUpTimerId);
        cancelAnimationFrame(lapTimerId);
        if (lapFixedDisplayTimeoutId) {
            clearTimeout(lapFixedDisplayTimeoutId);
        }
    } else if (swState === SW_STATE.PAUSE) {
        swState = SW_STATE.RUN;
        const now = Date.now();
        const pausedTime = now - lapStartTime;
        startTime += pausedTime;
        lapStartTime = now;
        countUp();
        startRealtimeLap();
    }
    updateButtonDisplay();
};

const resetStopwatch = () => {
    console.log("reset stopwatch");
    swState = SW_STATE.STOP;
    startTime = 0;
    lapRecords = [];
    lapCount = 0;
    cancelAnimationFrame(countUpTimerId);
    cancelAnimationFrame(lapTimerId);
    if (lapFixedDisplayTimeoutId) {
        clearTimeout(lapFixedDisplayTimeoutId);
    }
    totalTimePrint(0);
    if (elem.lap_list) elem.lap_list.innerHTML = '';
    if (elem.display1) elem.display1.textContent = '00:00.000';
    
    stopGps();
    if (elem.gpsButton) {
        elem.gpsButton.classList.remove('active-blue');
        elem.gpsButton.classList.add('no-gps');
    }
};


const clickLapSW = () => {
    console.log("lap/reset button clicked");
    
    if (swState === SW_STATE.RUN) {
        // RUN‰∏≠„ÅØLAPÊ©üËÉΩ
        lapCount++;
        const now = Date.now();
        const lapDuration = now - lapStartTime;
        lapTimePrint(lapDuration); 
        lapStartTime = now;
        cancelAnimationFrame(lapTimerId);
        startRealtimeLap();
        
    } else if (swState === SW_STATE.PAUSE) {
        // PAUSE‰∏≠„ÅØRESETÊ©üËÉΩ
        resetStopwatch();
    }
    updateButtonDisplay();
};

const clickGpsButton = () => {
    console.log("GPS button clicked");
    if (!isGpsRunning) {
        startGps();
    } else {
        stopGps();
    }
};

function startGps() {
    if (!isSettingsLoaded) {
        elem.debugInfo.innerHTML = "GPSË®≠ÂÆö„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ<br>GET„Éú„Çø„É≥„ÇíÊäº„Åó„Å¶Ë®≠ÂÆö„ÇíË™≠„ÅøËæº„Çì„Åß„Åè„Å†„Åï„ÅÑ„ÄÇ";
        return;
    }

    elem.statusDisplay.textContent = 'GPSÁõ£Ë¶ñ‰∏≠...';
    gpsWatchId = navigator.geolocation.watchPosition(
        onGpsPositionUpdate,
        onGpsError,
        { "enableHighAccuracy": true, "timeout": 20000, "maximumAge": 0 }
    );
    isGpsRunning = true;
    elem.gpsButton.textContent = 'GPS';
    elem.gpsButton.classList.remove('no-gps');
    elem.gpsButton.classList.add('active-blue');
}

function stopGps() {
    if (gpsWatchId !== null) {
        navigator.geolocation.clearWatch(gpsWatchId);
        gpsWatchId = null;
        isGpsRunning = false;
        elem.statusDisplay.textContent = 'GPSÁõ£Ë¶ñÂÅúÊ≠¢';
        elem.gpsButton.textContent = 'GPS';
        elem.gpsButton.classList.remove('active-blue');
        elem.gpsButton.classList.add('no-gps');
    }
}

const getSettings = () => {
    console.log("GET button clicked");
    
    // --- GPSË®≠ÂÆö„ÅÆË™≠„ÅøËæº„Åø ---
    const p1Lat = localStorage.getItem('startLineP1Lat');
    const p1Lon = localStorage.getItem('startLineP1Lon');
    const p2Lat = localStorage.getItem('startLineP2Lat');
    const p2Lon = localStorage.getItem('startLineP2Lon');
    const threshold = localStorage.getItem('gpsThreshold');
    const coolDown = localStorage.getItem('lapCoolDownTime'); 

    if (p1Lat && p1Lon && p2Lat && p2Lon) {
        LAP_LINE_P1 = { lat: parseFloat(p1Lat), lon: parseFloat(p1Lon) };
        LAP_LINE_P2 = { lat: parseFloat(p2Lat), lon: parseFloat(p2Lon) };
        gpsThresholdValue = threshold ? parseFloat(threshold) : 20;
        lapCoolDown = coolDown ? parseFloat(coolDown) : 15000; 

        elem.statusDisplay.textContent = `GPSË®≠ÂÆö: OK (ÈñæÂÄ§: ${gpsThresholdValue}m / „ÇØ„Éº„É´„ÉÄ„Ç¶„É≥: ${lapCoolDown / 1000}Áßí)`;
        elem.debugInfo.textContent = "GPSË®≠ÂÆö„ÅåË™≠„ÅøËæº„Åæ„Çå„Åæ„Åó„Åü„ÄÇ";
        isSettingsLoaded = true;
        elem.getSettingsBtn.classList.remove('no-setting');
        elem.getSettingsBtn.classList.add('active-blue');
    } else {
        elem.statusDisplay.textContent = 'GPSË®≠ÂÆö: Êú™Ë®≠ÂÆöÔºàË®≠ÂÆö„ÉÑ„Éº„É´„Åß‰øùÂ≠ò„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºâ';
        elem.debugInfo.textContent = "localStorage„Å´GPSË®≠ÂÆö„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ";
        isSettingsLoaded = false;
        elem.getSettingsBtn.classList.remove('active-blue');
        elem.getSettingsBtn.classList.add('no-setting');
    }
    
    // --- WebSocketÊé•Á∂ö„Éõ„Çπ„ÉàÂêç„ÅÆË™≠„ÅøËæº„Åø ---
    const storedHost = localStorage.getItem(API_ENDPOINT_KEY);
    if (storedHost) {
        console.log(`Loaded WS Host/IP: ${storedHost}`);
    } else {
        console.log("WS Host/IP not set in localStorage.");
    }
    
    // Wi-Fi„Éú„Çø„É≥„ÅÆÂàùÊúüÁä∂ÊÖãË®≠ÂÆö
    updateWifiButtonDisplay();
};

// ... onGpsPositionUpdate, onGpsError (GPSÈñ¢ÈÄ£Èñ¢Êï∞„ÅØÂ§âÊõ¥„Å™„Åó) ...

function onGpsPositionUpdate(position) {
    if (swState !== SW_STATE.RUN || !isGpsRunning) {
        return;
    }
    
    const currentLat = position.coords.latitude;
    const currentLon = position.coords.longitude;
    const currentTime = Date.now();
    
    // „Éò„É´„Éë„ÉºÈñ¢Êï∞Áæ§ÔºàÁúÅÁï•Ôºâ
    const calculateDistance = (lat1, lon1, lat2, lon2) => {
        const R = 6371e3;
        const œÜ1 = lat1 * Math.PI / 180;
        const œÜ2 = lat2 * Math.PI / 180;
        const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
        const ŒîŒª = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    };
    
    const calculatePerpendicularFootApprox = (lineLat1, lineLon1, lineLat2, lineLon2, pointLat, pointLon) => {
        const dx = lineLon2 - lineLon1;
        const dy = lineLat2 - lineLat1;
        const lineLenSq = dx * dx + dy * dy;
        if (lineLenSq < 1e-9) return { latitude: lineLat1, longitude: lineLon1 };
        const t = ((pointLon - lineLon1) * dx + (pointLat - lineLat1) * dy) / lineLenSq;
        if (t < 0) return { latitude: lineLat1, longitude: lineLon1 };
        if (t > 1) return { latitude: lineLat2, longitude: lineLon2 };
        return { latitude: lineLat1 + t * dy, longitude: lineLon1 + t * dx };
    };
    
    const getSideOfLine = (pointLat, pointLon, lineLat1, lineLon1, lineLat2, lineLon2) => {
        return (lineLon2 - lineLon1) * (pointLat - lineLat1) - (lineLat2 - lineLat1) * (pointLon - lineLon1);
    };

    const getIntersectionTime = (p1, p2, l1, l2, l3, l4) => {
        const A = (l4 - l2) * (p2.lon - p1.lon) - (l3 - l1) * (p2.lat - p1.lat);
        if (A === 0) return null;
        const B = (l3 - l1) * (p1.lat - l2) - (l4 - l2) * (p1.lon - l1);
        const ratio = B / A;
        if (ratio < 0 || ratio > 1) return null;
        return p1.time + (p2.time - p1.time) * ratio;
    };

    if (!lastPosition) {
        lastPosition = { lat: currentLat, lon: currentLon, time: currentTime, speed: position.coords.speed };
        previousSideOfLine = getSideOfLine(currentLat, currentLon, LAP_LINE_P1.lat, LAP_LINE_P1.lon, LAP_LINE_P2.lat, LAP_LINE_P2.lon);
        return;
    }

    const currentSideOfLine = getSideOfLine(currentLat, currentLon, LAP_LINE_P1.lat, LAP_LINE_P1.lon, LAP_LINE_P2.lat, LAP_LINE_P2.lon);
    const isCrossingLine = (previousSideOfLine > 0 && currentSideOfLine < 0) || (previousSideOfLine < 0 && currentSideOfLine > 0);
    const timeSinceLastLap = currentTime - lastLapTime;
    const isCoolDownOver = (lapCount === 0) || (timeSinceLastLap >= lapCoolDown);

    const P = calculatePerpendicularFootApprox(LAP_LINE_P1.lat, LAP_LINE_P1.lon, LAP_LINE_P2.lat, LAP_LINE_P2.lon, currentLat, currentLon);
    const distanceToStartLine = calculateDistance(currentLat, currentLon, P.latitude, P.longitude);
    const isNearStartLine = distanceToStartLine <= gpsThresholdValue;

    if (isCrossingLine && isCoolDownOver && isNearStartLine) {
        const timeDelta = currentTime - lastPosition.time;
        const speed = position.coords.speed || 0; 
        const distanceMoved = speed * timeDelta / 1000; 
        
        const deltaLat = currentLat - lastPosition.lat;
        const deltaLon = currentLon - lastPosition.lon;
        const currentToLastDistance = calculateDistance(currentLat, currentLon, lastPosition.lat, lastPosition.lon);

        let predictedLat, predictedLon;
        if (currentToLastDistance > 0) {
            const ratio = distanceMoved / currentToLastDistance;
            predictedLat = currentLat + deltaLat * ratio;
            predictedLon = currentLon + deltaLon * ratio;
        } else {
            predictedLat = currentLat;
            predictedLon = currentLon;
        }

        const predictedPosition = {
            lat: predictedLat,
            lon: predictedLon,
            time: currentTime + timeDelta
        };

        const estimatedCrossingTime = getIntersectionTime(lastPosition, predictedPosition, LAP_LINE_P1.lat, LAP_LINE_P1.lon, LAP_LINE_P2.lat, LAP_LINE_P2.lon);
        
        let lapTimeBase;
        if (estimatedCrossingTime && Math.abs(estimatedCrossingTime - currentTime) < 10000) {
            lapTimeBase = estimatedCrossingTime;
        } else {
            lapTimeBase = currentTime;
        }

        lapCount++;
        const lapDuration = lapTimeBase - lapStartTime;
        lapTimePrint(lapDuration); 
        
        cancelAnimationFrame(lapTimerId);
        if (elem.display1) elem.display1.textContent = lapTimeToString(lapDuration);

        if (lapFixedDisplayTimeoutId) {
             clearTimeout(lapFixedDisplayTimeoutId);
        }
        lapFixedDisplayTimeoutId = setTimeout(() => {
            if (swState === SW_STATE.RUN) {
                lapStartTime = lapTimeBase;
                startRealtimeLap();
            }
        }, 10000);
        
        lastLapTime = lapTimeBase;
    }

    lastPosition = { lat: currentLat, lon: currentLon, time: currentTime, speed: position.coords.speed };
    previousSideOfLine = currentSideOfLine;

    const logText = `Ë∑ùÈõ¢: ${distanceToStartLine.toFixed(2)} m<br>ÈÄüÂ∫¶: ${(position.coords.speed || 0).toFixed(2)} m/s<br>„É©„Ç§„É≥ÈÄöÈÅé: ${isCrossingLine}<br>Âë®ÂõûÊï∞: ${lapCount}`;
    elem.debugInfo.innerHTML = logText;
}

function onGpsError(error) {
    elem.debugInfo.textContent = `GPS„Ç®„É©„Éº: ${error.message}`;
    elem.gpsButton.classList.remove('active-blue');
    elem.gpsButton.classList.add('no-gps');
    stopGps();
}

// ----------------------------------------------------
// ‚òÖ‚òÖ‚òÖ WebSocketÈñ¢ÈÄ£Èñ¢Êï∞Ôºà„Éá„Éê„ÉÉ„Ç∞Âº∑Âåñ„Éª„Éõ„Çπ„ÉàÂÖ•ÂäõÂº∑ÂåñÔºâ ‚òÖ‚òÖ‚òÖ
// ----------------------------------------------------

// Wi-Fi„Éú„Çø„É≥„ÅÆË°®Á§∫„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
const updateWifiButtonDisplay = () => {
    if (!elem.wifiButton) return;

    if (socket && socket.readyState === WebSocket.OPEN) {
        elem.wifiButton.classList.remove('wifi-disconnected', 'wifi-connecting', 'wifi-error');
        elem.wifiButton.classList.add('wifi-connected');
        elem.wifiButton.textContent = 'Wi-Fi (Êé•Á∂ö‰∏≠)';
    } else if (socket && socket.readyState === WebSocket.CONNECTING) {
        elem.wifiButton.classList.remove('wifi-disconnected', 'wifi-connected', 'wifi-error');
        elem.wifiButton.classList.add('wifi-connecting');
        elem.wifiButton.textContent = 'Wi-Fi (Êé•Á∂öË©¶Ë°å‰∏≠)';
    } else if (socket && socket.readyState === WebSocket.CLOSED) {
        elem.wifiButton.classList.remove('wifi-connected', 'wifi-connecting');
        elem.wifiButton.classList.add('wifi-disconnected', 'wifi-error');
        elem.wifiButton.textContent = 'Wi-Fi (ÂàáÊñ≠/„Ç®„É©„Éº)';
    } else {
        const storedHost = localStorage.getItem(API_ENDPOINT_KEY);
        elem.wifiButton.classList.remove('wifi-connected', 'wifi-connecting', 'wifi-error');
        elem.wifiButton.classList.add('wifi-disconnected');
        elem.wifiButton.textContent = storedHost ? 'Wi-Fi (ÂàáÊñ≠)' : 'Wi-Fi (Êú™Ë®≠ÂÆö)';
    }
}

// „Éî„ÉÉ„Éà„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆË°®Á§∫„ÇíÂà∂Âæ°„Åô„ÇãÈñ¢Êï∞
const displayPitMessage = (message, isError = false) => {
    if (elem.pitMessageDisplay) {
        const trimmedMessage = message ? message.trim() : '';
        
        if (trimmedMessage === '' || trimmedMessage.toLowerCase() === '„Å™„Åó' || trimmedMessage.toLowerCase() === 'clear') {
            elem.pitMessageDisplay.textContent = '';
            elem.pitMessageDisplay.style.display = 'none';
        } else {
            elem.pitMessageDisplay.textContent = trimmedMessage;
            elem.pitMessageDisplay.style.display = 'block';
            if (isError) {
                elem.pitMessageDisplay.style.color = '#ff4d4d'; // Ëµ§Ëâ≤
            } else {
                elem.pitMessageDisplay.style.color = '#ffeb3b'; // ÈªÑËâ≤
            }
        }
        
        // „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±„Å´„ÇÇ„É≠„Ç∞Âá∫Âäõ
        if (elem.debugInfo) {
            // „Ç®„É©„Éº„ÇÑÊé•Á∂öÊÉÖÂ†±„ÅØËâ≤„ÇíÂ§â„Åà„Å¶Ë°®Á§∫
            const color = isError || trimmedMessage.includes('„Ç®„É©„Éº') || trimmedMessage.includes('Â§±Êïó') ? '#ff4d4d' : '#999999';
            const logEntry = `<br><span style="color: ${color};">[WS Log] ${trimmedMessage}</span>`;
            
            // Âè§„ÅÑ„É≠„Ç∞„Çí‰øùÊåÅ„Åó„Åô„Åé„Å™„ÅÑ„Çà„ÅÜ„Å´Ë™øÊï¥
            let currentLogs = elem.debugInfo.innerHTML;
            const logLines = currentLogs.split('<br>').filter(line => !line.startsWith('GPSË®≠ÂÆö:'));
            
            // „É≠„Ç∞„ÅåÂ§ö„ÅÑÂ†¥Âêà„ÅØÂè§„ÅÑ„ÇÇ„ÅÆ„ÇíÂâäÈô§
            if (logLines.length > 5) {
                logLines.splice(1, logLines.length - 5); 
            }
            
            elem.debugInfo.innerHTML = elem.statusDisplay.outerHTML + '<p class="status-text">' + logLines.join('<br>') + '</p>' + logEntry;
        }
    }
}

// WebSocket„Å∏„ÅÆÊé•Á∂ö„ÇíË©¶Ë°å„Åô„ÇãÈñ¢Êï∞
function connectWebSocket() {
    if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
        console.log('WebSocket„ÅØÊó¢„Å´Êé•Á∂ö‰∏≠„Åæ„Åü„ÅØÊé•Á∂öË©¶Ë°å‰∏≠„Åß„Åô„ÄÇ');
        return;
    }
    
    const storedHost = localStorage.getItem(API_ENDPOINT_KEY);
    if (!storedHost) {
        console.log("WebSocketÊé•Á∂öÂÖà„Éõ„Çπ„Éà/IP„ÅåÊú™Ë®≠ÂÆö„Åß„Åô„ÄÇ");
        displayPitMessage('Wi-Fi„Éõ„Çπ„Éà„ÅåÊú™Ë®≠ÂÆö„Åß„Åô', true);
        updateWifiButtonDisplay();
        return;
    }

    // storedHost (IP„Ç¢„Éâ„É¨„Çπ„Åæ„Åü„ÅØ„Éõ„Çπ„ÉàÂêç) „Çí‰ΩøÁî®„Åó„Å¶URL„Çí‰ΩúÊàê
    // WS_PORT„Åå80„ÅÆÂ†¥Âêà„ÄÅ„Éù„Éº„ÉàÁï™Âè∑„ÅØÁúÅÁï•ÂèØËÉΩ„Åß„Åô„Åå„ÄÅÊòéÁ§∫ÁöÑ„Å´Âê´„ÇÅ„Å¶„Åä„Åç„Åæ„Åô„ÄÇ
    const wsUrl = `ws://${storedHost}:${WS_PORT}${WS_PATH}`;
    
    if (connectAttemptTimerId) {
        clearTimeout(connectAttemptTimerId);
        connectAttemptTimerId = null;
    }
    
    try {
        // üö® ‰øÆÊ≠£„Éù„Ç§„É≥„Éà: „Åì„Åì„ÅßÂàùÊúüÂåñÂ§±Êïó„ÅåËµ∑„Åç„ÇãÂ†¥Âêà„ÅØ„ÄÅURLÂΩ¢Âºè„ÅåÂïèÈ°å„ÅÆÂèØËÉΩÊÄß„ÅåÈ´ò„ÅÑ
        socket = new WebSocket(wsUrl); 
        
        updateWifiButtonDisplay();
        displayPitMessage(`Êé•Á∂öË©¶Ë°å‰∏≠: ${wsUrl}`);
        console.log(`WebSocketÊé•Á∂ö„ÇíË©¶Ë°å‰∏≠... ${wsUrl}`);

        socket.onopen = function() {
            console.log('‚úÖ WebSocketÊé•Á∂öÁ¢∫Á´ã');
            retryCount = 0; 
            updateWifiButtonDisplay();
            displayPitMessage('WebSocketÊé•Á∂öÂÆå‰∫Ü');
        };

        socket.onmessage = function(event) {
            // Âèó‰ø°„Éá„Éº„Çø„ÅØ„Éî„ÉÉ„Éà„É°„ÉÉ„Çª„Éº„Ç∏„ÅÆ„Éó„É¨„Éº„É≥„ÉÜ„Ç≠„Çπ„Éà„ÇíÊÉ≥ÂÆö
            const message = event.data;
            displayPitMessage(message);
        };

        socket.onclose = function(event) {
            const shouldRetry = event.code !== 1000 && socket !== null;
            
            console.warn(`‚ùå WebSocketÊé•Á∂öÂàáÊñ≠: „Ç≥„Éº„Éâ ${event.code}, ÁêÜÁî±: ${event.reason}`);
            updateWifiButtonDisplay();
            
            if (shouldRetry) {
                if (connectAttemptTimerId) {
                    clearTimeout(connectAttemptTimerId);
                }

                const delay = Math.min(1000 * Math.pow(2, retryCount), 30000); 
                retryCount++;
                displayPitMessage(`Êé•Á∂ö„Ç®„É©„Éº„ÄÇ${delay / 1000}ÁßíÂæå„Å´ÂÜçË©¶Ë°å (${retryCount}ÂõûÁõÆ)`, true);
                
                connectAttemptTimerId = setTimeout(connectWebSocket, delay); 
            } else {
                displayPitMessage('Wi-FiÊé•Á∂ö„ÅåÁµÇ‰∫Ü„Åó„Åæ„Åó„Åü');
            }
        };

        socket.onerror = function(error) {
            console.error('‚ùå WebSocket„Ç®„É©„Éº:', error);
            // „Ç®„É©„Éº„ÅåÁô∫Áîü„Åô„Çã„Å® onclose „ÅåÂëº„Å∞„Çå„Å¶ÂÜçÊé•Á∂öÂá¶ÁêÜ„ÅåËµ∞„Çã
        };

    } catch (e) {
        // üö® ÂàùÊúüÂåñÊôÇ„Å´‰æãÂ§ñ„ÅåÁô∫Áîü„Åó„ÅüÂ†¥ÂêàÔºàURL„ÅÆÂΩ¢Âºè„Ç®„É©„Éº„Å™„Å©Ôºâ
        console.error('WebSocket„ÅÆÂàùÊúüÂåñ‰∏≠„Å´Ëá¥ÂëΩÁöÑ„Å™„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü:', e);
        socket = null;
        // ‰ª•Ââç„ÅÆ„Ç®„É©„Éº„É°„ÉÉ„Çª„Éº„Ç∏„Çí„Çà„ÇäË©≥Á¥∞„Å™„ÇÇ„ÅÆ„Å´ÁΩÆ„ÅçÊèõ„Åà„Çã
        displayPitMessage(`WebSocketÂàùÊúüÂåñÂ§±Êïó: [${e.name}] URLÂΩ¢Âºè„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ: ${wsUrl}`, true);
        updateWifiButtonDisplay();
    }
}

// WebSocketÊé•Á∂ö„ÇíÊòéÁ§∫ÁöÑ„Å´Èñâ„Åò„ÇãÈñ¢Êï∞
function disconnectWebSocket() {
    if (socket) {
        console.log("WebSocket„ÇíÂàáÊñ≠‰∏≠...");
        socket.onclose = function(event) {
            console.log('‚úÖ WebSocketÊòéÁ§∫ÁöÑ„Å´ÂàáÊñ≠„Åï„Çå„Åæ„Åó„Åü');
            if (connectAttemptTimerId) {
                clearTimeout(connectAttemptTimerId);
                connectAttemptTimerId = null;
            }
            socket = null;
            retryCount = 0;
            updateWifiButtonDisplay();
            displayPitMessage('Wi-FiÊé•Á∂öÂÅúÊ≠¢');
        }; 
        socket.close(1000, 'User disconnect'); 
    } else {
        if (connectAttemptTimerId) {
            clearTimeout(connectAttemptTimerId);
            connectAttemptTimerId = null;
        }
        retryCount = 0;
        updateWifiButtonDisplay();
        displayPitMessage('Wi-FiÊé•Á∂öÂÅúÊ≠¢');
    }
}

// üö® ‰øÆÊ≠£„Éù„Ç§„É≥„Éà: „Éõ„Çπ„ÉàÂÖ•ÂäõÊôÇ„ÅÆÊñáÂ≠óÂàó„Çí„ÇØ„É™„Éº„Éã„É≥„Ç∞„Åô„Çã
function setWsHost() {
    const currentHost = localStorage.getItem(API_ENDPOINT_KEY) || "192.168.4.1"; // „Éá„Éï„Ç©„É´„ÉàÂÄ§„ÇíÊòéÁ§∫
    
    // ÂÖ•Âäõ„Éó„É≠„É≥„Éó„Éà
    let newHost = prompt("Wi-FiÊé•Á∂öÂÖà„Éõ„Çπ„Éà/IP„Ç¢„Éâ„É¨„Çπ„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ (‰æã: 192.168.4.1)", currentHost);
    
    if (newHost) {
        // 1. ÂâçÂæå„ÅÆÁ©∫ÁôΩ„ÇíÂâäÈô§
        newHost = newHost.trim();
        
        // 2. http://, https://, ws://, wss:// „Å™„Å©„ÅÆ„Éó„É≠„Éà„Ç≥„É´„ÇíÈô§Âéª
        newHost = newHost.replace(/^(https?|wss?):\/\//i, '');
        
        // 3. „Éù„Éº„ÉàÁï™Âè∑„ÇÑ„Éë„Çπ„Åå„ÅÇ„Çå„Å∞„Åù„Çå„Çà„ÇäÊâãÂâç„ÅßÂàáÊñ≠
        // ‰æã: 192.168.4.1:81/ws -> 192.168.4.1:81 „ÇíÂèñÂæó
        let parts = newHost.split('/');
        newHost = parts[0]; 

        // 4. IP„Ç¢„Éâ„É¨„Çπ„ÅÆÂΩ¢Âºè„ÉÅ„Çß„ÉÉ„ÇØÔºàÁ∞°ÊòìÁöÑÔºâ
        if (!newHost.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(:\d+)?$/)) {
             displayPitMessage("IP„Ç¢„Éâ„É¨„Çπ„Åæ„Åü„ÅØ„Éõ„Çπ„ÉàÂêç„ÅÆÂΩ¢Âºè„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇ", true);
             return false;
        }

        // 5. „Éù„Éº„ÉàÁï™Âè∑„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Åù„Çå„ÇíWS_PORT„Å®„Åó„Å¶Âà©Áî®ÂèØËÉΩ
        let [host, port] = newHost.split(':');
        
        // „Åì„ÅÆ„Ç¢„Éó„É™„Åß„ÅØ„Éù„Éº„ÉàÁï™Âè∑„ÇíÂÆöÊï∞„Å®„Åó„Å¶Êâ±„Å£„Å¶„ÅÑ„Çã„Åü„ÇÅ„ÄÅ„Éõ„Çπ„ÉàÂêçÈÉ®ÂàÜ„ÅÆ„Åø„Çí‰øùÂ≠ò
        localStorage.setItem(API_ENDPOINT_KEY, host);

        displayPitMessage(`„Éõ„Çπ„ÉàË®≠ÂÆöÂÆå‰∫Ü: ${host} („Éù„Éº„Éà: ${WS_PORT})`);
        return true;
    }
    return false;
}

const clickWifiButton = () => {
    console.log("Wi-Fi button clicked");
    
    if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
        disconnectWebSocket();
    } else {
        const storedHost = localStorage.getItem(API_ENDPOINT_KEY);
        
        if (!storedHost) {
            if (setWsHost()) {
                connectWebSocket(); 
            } else {
                displayPitMessage('„Éõ„Çπ„Éà„ÅÆË®≠ÂÆö„Çí„Ç≠„É£„É≥„Çª„É´„Åó„Åæ„Åó„Åü„ÄÇ');
            }
        } else {
            connectWebSocket(); 
        }
    }
};

// ----------------------------------------------------
// ‚òÖ‚òÖ‚òÖ ÂàùÊúüÂåñÂá¶ÁêÜÔºàload„Ç§„Éô„É≥„ÉàÔºâ ‚òÖ‚òÖ‚òÖ
// ----------------------------------------------------

window.addEventListener('load', () => {
    // Service Worker„ÅÆÁôªÈå≤ÔºàPWA„Å®„Åó„Å¶Âãï‰Ωú„Åï„Åõ„ÇãÂ†¥ÂêàÔºâ
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/service-worker.js')
            .then(registration => {
                console.log('Service Worker registered with scope:', registration.scope);
            })
            .catch(error => {
                console.log('Service Worker registration failed:', error);
            });
    }

    elem.display = document.getElementById('display');
    elem.display1 = document.getElementById('display1');
    elem.lap_list = document.getElementById('lap_list');
    elem.statusDisplay = document.getElementById('status-display');
    elem.debugInfo = document.getElementById('debugInfo');
    elem.startButton = document.getElementById('start');
    elem.lapButton = document.getElementById('lap'); 
    elem.gpsButton = document.getElementById('gpsButton');
    elem.getSettingsBtn = document.getElementById('getSettingsBtn');
    
    elem.wifiButton = document.getElementById('wifiButton'); 
    elem.pitMessageDisplay = document.getElementById('pitMessageDisplay');

    if (elem.startButton) elem.startButton.addEventListener('click', clickStartSW);
    if (elem.lapButton) elem.lapButton.addEventListener('click', clickLapSW); 
    if (elem.gpsButton) elem.gpsButton.addEventListener('click', clickGpsButton);
    if (elem.getSettingsBtn) elem.getSettingsBtn.addEventListener('click', getSettings);
    
    if (elem.wifiButton) elem.wifiButton.addEventListener('click', clickWifiButton); 
    
    updateButtonDisplay();
    totalTimePrint(0);
    if (elem.display1) elem.display1.textContent = '00:00.000';
    getSettings(); // GPSË®≠ÂÆö„Å®„Éõ„Çπ„Éà/IP„Ç¢„Éâ„É¨„Çπ„ÅÆË™≠„ÅøËæº„Åø
});
</script>
</body>
</html>
